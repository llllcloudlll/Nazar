<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NAZAR â€” Kalpler & Patlayan YÄ±ldÄ±zlar</title>
<style>
  :root{
    --bg:#030014; --card-bg:rgba(255,255,255,0.04);
    --pink1:#ff6eb6; --pink2:#ffb3db; --ui:#fff;
    --msg-bg:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--ui);background:var(--bg);overflow:hidden}
  /* Three wrapper */
  #three-wrap{position:fixed;inset:0;z-index:0}
  /* canvas for hearts/particles on top */
  #overlay{position:fixed;inset:0;z-index:8;pointer-events:none}
  /* UI card */
  #ui{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:18}
  .intro{width:min(820px,94%);padding:28px;border-radius:20px;background:var(--card-bg);backdrop-filter: blur(6px);text-align:center;border:1px solid rgba(255,255,255,0.05)}
  h1{font-size:26px;margin:0 0 10px;font-weight:800}
  p{opacity:.85;margin:0 0 18px}
  .cta{padding:14px 30px;border-radius:999px;border:0;background:linear-gradient(90deg,var(--pink1),#7b6bff);color:#fff;font-weight:800;cursor:pointer;box-shadow:0 12px 40px rgba(123,107,255,0.12)}
  .cta:active{transform:translateY(1px)}
  .hide{opacity:0;transform:translateY(-6%);pointer-events:none;transition:opacity .6s, transform .6s}

  /* center message card */
  .msgCard{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:22;min-width:320px;max-width:86%;padding:18px 22px;border-radius:14px;background:var(--msg-bg);border:1px solid rgba(255,255,255,0.06);text-align:center;font-weight:700;opacity:0;transition:opacity .45s, transform .45s}
  .msgCard.show{opacity:1;transform:translate(-50%,-48%)}

  /* final overlay */
  #final{position:fixed;inset:0;z-index:26;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85));opacity:0;pointer-events:none;transition:opacity .6s}
  #final.show{opacity:1;pointer-events:auto}
  .finalBox{background:rgba(255,255,255,0.03);padding:20px;border-radius:12px;text-align:center;border:1px solid rgba(255,255,255,0.04)}
  .replay{margin-top:10px;padding:10px 18px;border-radius:10px;border:0;background:transparent;color:var(--ui);cursor:pointer;border:1px solid rgba(255,255,255,0.06)}

  /* mobile tweaks */
  @media (max-width:600px){ h1{font-size:20px} .intro{padding:18px;border-radius:12px}}
</style>
</head>
<body>

<!-- Three.js renderer container -->
<div id="three-wrap" aria-hidden="true"></div>

<!-- Overlay canvas for hearts, confetti & fireworks -->
<canvas id="overlay" width="1600" height="900" aria-hidden="true"></canvas>

<!-- UI -->
<div id="ui">
  <div id="introCard" class="intro" role="dialog" aria-modal="true">
    <h1>AklÄ±ma geldin â€” nasÄ±l olduÄŸunu bilmek istedim</h1>
    <p>PeÅŸimden gel; adÄ±n kalplerle dalgamsÄ± bir ÅŸekilde gÃ¶kyÃ¼zÃ¼nde belirecek.</p>
    <button id="startBtn" class="cta">PeÅŸimden gel â†’</button>
    <div style="margin-top:10px;color:rgba(255,255,255,0.75);font-weight:600;font-size:13px">Pembe kalpler ile net okunabilirlik saÄŸlandÄ±.</div>
  </div>
</div>

<!-- Center messages -->
<div id="message" class="msgCard" role="status" aria-live="polite"></div>

<!-- Final -->
<div id="final">
  <div class="finalBox">
    <div style="font-size:20px;font-weight:900">ÅžÅŸÅŸâ€¦ ÅŸimdi dinlen</div>
    <div style="opacity:.9;margin-top:6px">GÃ¼lÃ¼ÅŸÃ¼n bulutlara yakÄ±ÅŸtÄ± ðŸ’–</div>
    <button id="replay" class="replay">Tekrar Oynat</button>
  </div>
</div>

<!-- three.js -->
<script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>

<script>
/* -----------------------
   CONFIG
   ----------------------- */
const CONF = {
  TEXT: "NAZAR",
  SAMPLE_STEP: 10,        // daha sÄ±k -> netlik, ama Ã§ok fazla olmasÄ±n
  PARTICLE_MAX: 1400,
  HEART_BASE: 9,
  WAVE_AMP: 16,
  WAVE_FREQ: 0.02,
  WAVE_SPEED: 0.006
};

/* -----------------------
   Three.js - 3D starfield + exploding star (firework) support
   ----------------------- */
let renderer, scene, camera, starLayers = [];
const container = document.getElementById('three-wrap');

function initThree(){
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0,0,500);

  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  container.appendChild(renderer.domElement);

  // layered starfields: far, mid, near
  function buildStars(count, size, zRange, color){
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count*3);
    const cols = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      pos[i*3] = (Math.random()*2-1) * innerWidth * 1.2;
      pos[i*3+1] = (Math.random()*2-1) * innerHeight * 1.1;
      pos[i*3+2] = -Math.random()*zRange - 80;
      const c = new THREE.Color(color);
      c.lerp(new THREE.Color(0xffffff), Math.random()*0.2);
      cols[i*3]=c.r; cols[i*3+1]=c.g; cols[i*3+2]=c.b;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geo.setAttribute('color', new THREE.BufferAttribute(cols,3));
    const mat = new THREE.PointsMaterial({size, vertexColors:true, transparent:true});
    return new THREE.Points(geo, mat);
  }

  starLayers.push(buildStars(1200,1.45,1800,0x9ab1ff));
  starLayers.push(buildStars(800,2.4,1100,0xa8fff6));
  starLayers.push(buildStars(520,3.8,650,0xffc6ee));
  starLayers.forEach(s=>scene.add(s));

  // tiny ambient
  scene.add(new THREE.AmbientLight(0x666677, 0.5));

  window.addEventListener('resize', onResize, {passive:true});
  animateThree();
}
function onResize(){ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); }
let tTick = 0;
function animateThree(){
  tTick += 0.003;
  camera.position.x = Math.sin(tTick*0.9) * 12;
  camera.position.y = Math.sin(tTick*0.6) * 8;
  camera.lookAt(0,0,0);
  starLayers.forEach((s, idx) => { s.rotation.z += 0.0002*(idx+1); s.position.z += Math.sin(tTick * (0.2 + idx*0.05)) * 0.03; });
  renderer.render(scene, camera);
  requestAnimationFrame(animateThree);
}

/* fireworks: create simple particle systems when triggered using Three.js Points */
function spawnFirework(xNorm, yNorm){
  // normalized screen coords to world coords
  // We will spawn some small glowing points that expand
  const count = 160 + Math.floor(Math.random()*80);
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const col = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const r = Math.random()*120 + 10;
    pos[i*3] = (xNorm - 0.5) * innerWidth + Math.cos(ang)*2;
    pos[i*3+1] = (0.5 - yNorm) * innerHeight + Math.sin(ang)*2 - 40;
    pos[i*3+2] = -200 - Math.random()*300;
    const c = new THREE.Color(Math.random()>.5?0xffd6f0:0x9ef7ff);
    c.lerp(new THREE.Color(0xffffff), Math.random()*0.2);
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));
  const mat = new THREE.PointsMaterial({size:3.6, vertexColors:true, transparent:true, opacity:0.95});
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);

  // expand and fade over time
  let life = 0;
  const dur = 1400 + Math.random()*700;
  const start = performance.now();
  function fwLoop(now){
    life = now - start;
    const s = Math.min(1, life / dur);
    // move points outwards in their radial directions
    const arr = geo.attributes.position.array;
    for(let i=0;i<arr.length;i+=3){
      arr[i] += (arr[i]*0.0004) + (Math.random()-0.5) * 0.3 * s;
      arr[i+1] += (arr[i+1]*0.0004) + (Math.random()-0.5) * 0.3 * s;
    }
    geo.attributes.position.needsUpdate = true;
    pts.material.opacity = 1 - s;
    if(s < 1) requestAnimationFrame(fwLoop); else { scene.remove(pts); geo.dispose(); pts.material.dispose(); }
  }
  requestAnimationFrame(fwLoop);
}

/* -----------------------
   Overlay canvas: hearts forming TEXT, confetti, heart bursts
   ----------------------- */
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d', { alpha:true });
let W = overlay.width = innerWidth;
let H = overlay.height = innerHeight;
window.addEventListener('resize', () => { W = overlay.width = innerWidth; H = overlay.height = innerHeight; createTargets(); });

/* draw heart path helper */
function drawHeartPath(ctx, s){
  const r = s*0.55;
  ctx.moveTo(0, -r*0.2);
  ctx.bezierCurveTo(r*1.1, -r*1.1, r*2.0, r*0.1, 0, r*1.6);
  ctx.bezierCurveTo(-r*2.0, r*0.1, -r*1.1, -r*1.1, 0, -r*0.2);
}

/* sample text targets */
let targets = [];
function createTargets(){
  const off = document.createElement('canvas');
  const oc = off.getContext('2d');
  off.width = Math.floor(W * 0.9);
  off.height = Math.floor(H * 0.36);
  // choose font size to fill horizontally but allow spacing
  let fsize = Math.floor(off.height * 0.9);
  oc.font = `900 ${fsize}px Arial`; oc.textAlign='center'; oc.textBaseline='middle';
  const metrics = oc.measureText(CONF.TEXT);
  if(metrics.width > off.width*0.92){
    const factor = (off.width*0.92)/metrics.width;
    fsize = Math.floor(fsize * factor);
  }
  oc.clearRect(0,0,off.width,off.height);
  oc.fillStyle='white'; oc.font = `900 ${fsize}px Arial`;
  oc.fillText(CONF.TEXT, off.width/2, off.height/2);
  const data = oc.getImageData(0,0,off.width,off.height).data;
  targets = [];
  const step = Math.max(6, CONF.SAMPLE_STEP); // ensure not too tight
  for(let y=0;y<off.height;y+=step){
    for(let x=0;x<off.width;x+=step){
      const alpha = data[(y*off.width + x)*4 + 3];
      if(alpha > 140){ // strong pixel -> kept for readability
        const sx = (x/off.width) * (W*0.86) + (W*0.07);
        const sy = (y/off.height) * (H*0.34) + (H*0.24);
        targets.push({x:sx, y:sy});
      }
    }
  }
  // reduce if over cap but keep even spacing
  if(targets.length > CONF.PARTICLE_MAX){
    const reduced = [];
    const step2 = Math.ceil(targets.length / CONF.PARTICLE_MAX);
    for(let i=0;i<targets.length;i+=step2) reduced.push(targets[i]);
    targets = reduced;
  }
  // apply initial wave to y for dalgamsÄ±
  for(let i=0;i<targets.length;i++){
    const t = targets[i];
    t.oy = t.y;
    t.y += Math.sin(t.x * CONF.WAVE_FREQ) * CONF.WAVE_AMP;
  }
}
createTargets();

/* Heart particle */
class H {
  constructor(t){
    // start from bottom or sides
    const choice = Math.random();
    if(choice<0.45){ this.x = Math.random()*W; this.y = H + Math.random()*200; }
    else if(choice<0.8){ this.x = -80 - Math.random()*200; this.y = Math.random()*H*0.6 + H*0.15; }
    else { this.x = W + 80 + Math.random()*200; this.y = Math.random()*H*0.6 + H*0.15; }
    this.vx = (Math.random()-0.5)*4; this.vy = -2 - Math.random()*2;
    this.tx = t.x; this.ty = t.y; this.oy = t.y;
    this.size = CONF.HEART_BASE * (0.9 + Math.random()*0.6);
    this.color = Math.random()>.5 ? '#ff6eb6' : '#ffb3db'; // pembe temalÄ±
    this.arr = false;
    this.delay = Math.random()*700;
    this.phase = Math.random()*Math.PI*2;
  }
  update(dt, gPhase){
    if(this.delay > 0){ this.delay -= dt; return; }
    const waveOffset = Math.sin((this.tx * CONF.WAVE_FREQ) + gPhase + this.phase) * (CONF.WAVE_AMP * 0.45);
    const targetY = this.oy + waveOffset;
    const ax = (this.tx - this.x) * 0.015;
    const ay = (targetY - this.y) * 0.015;
    this.vx += ax; this.vy += ay;
    this.vx *= 0.92; this.vy *= 0.92;
    this.x += this.vx; this.y += this.vy;
    if(Math.hypot(this.tx - this.x, targetY - this.y) < 3){
      this.arr = true; this.x = this.tx; this.y = targetY;
    }
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y + Math.sin(this.phase + performance.now()*0.002)*0.6);
    ctx.globalCompositeOperation = 'lighter';
    const grad = ctx.createRadialGradient(0,0,this.size*0.1,0,0,this.size*2.2);
    grad.addColorStop(0, hexToRgba(this.color,0.28));
    grad.addColorStop(1, hexToRgba(this.color,0));
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(0,0,this.size*1.6,0,Math.PI*2); ctx.fill();
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    drawHeartPath(ctx, this.size);
    ctx.fill();
    // highlight
    ctx.fillStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath(); ctx.ellipse(-this.size*0.18, -this.size*0.5, this.size*0.14, this.size*0.07, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function hexToRgba(hex,a){
  const h=hex.replace('#',''); const r=parseInt(h.substring(0,2),16); const g=parseInt(h.substring(2,4),16); const b=parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* heart pool & render */
let hearts = [], anim=false, globalPhase=0, lastTime = performance.now();

function spawnHearts(){
  hearts = [];
  const tcopy = targets.slice();
  // shuffle
  for(let i=tcopy.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [tcopy[i],tcopy[j]]=[tcopy[j],tcopy[i]]; }
  const use = Math.min(tcopy.length, CONF.PARTICLE_MAX);
  for(let i=0;i<use;i++) hearts.push(new H(tcopy[i]));
  anim = true;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function loop(now){
  const dt = now - lastTime; lastTime = now;
  globalPhase += CONF.WAVE_SPEED * dt;
  ctx.clearRect(0,0,W,H);
  let arrived = 0;
  for(const h of hearts){ h.update(dt, globalPhase); h.draw(ctx); if(h.arr) arrived++; }
  if(anim && arrived / hearts.length > 0.94){
    anim = false;
    onFormed();
  } else if(anim) requestAnimationFrame(loop);
}

/* on form complete: trigger confetti, fireworks and heart bursts */
function onFormed(){
  // small pop pulses on hearts
  for(const h of hearts){ h.size *= 1.05; setTimeout(()=> h.size /= 1.05, 380 + Math.random()*200); }
  // trigger confetti volleys and fireworks (three)
  for(let i=0;i<4;i++){
    setTimeout(()=> spawnConfettiBurst(W*0.15 + Math.random()*W*0.7, H*0.25 + Math.random()*H*0.25), i*350);
    setTimeout(()=> spawnFirework((0.2 + Math.random()*0.6)/1, (0.28 + Math.random()*0.42)/1), i*500); // three fireworks
  }
  // small heart burst near center
  spawnHeartBurst(W/2, H*0.32);
}

/* confetti via 2D particles */
let confettis = [];
function spawnConfettiBurst(x,y){
  const count = 60 + Math.floor(Math.random()*40);
  for(let i=0;i<count;i++){
    confettis.push({
      x, y,
      vx: (Math.random()-0.5)*6,
      vy: -2 - Math.random()*6,
      r: 4 + Math.random()*6,
      c: Math.random()>.5 ? '#ff6eb6' : '#ffd6ee',
      life: 1800 + Math.random()*1000,
      born: performance.now()
    });
  }
  // animate confetti along with hearts (same loop)
  if(!anim) requestAnimationFrame(confettiLoop);
}

function confettiLoop(now){
  if(!now) now = performance.now();
  // clear only confetti layer (we'll redraw hearts separately)
  // but simpler: draw confetti on top of hearts context without clearing hearts (we clear whole ctx earlier). To avoid flicker, we integrate confetti drawing into main loop by scheduling.
  const alive = [];
  for(const p of confettis){
    const age = now - p.born;
    if(age < p.life){
      p.vy += 0.14; p.x += p.vx; p.y += p.vy;
      ctx.save();
      ctx.globalAlpha = 1 - (age / p.life);
      ctx.translate(p.x, p.y);
      ctx.rotate(age*0.007);
      ctx.fillStyle = p.c;
      ctx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6);
      ctx.restore();
      alive.push(p);
    }
  }
  confettis = alive;
  if(confettis.length) requestAnimationFrame(confettiLoop);
}

/* heart burst small */
function spawnHeartBurst(x,y){
  const count = 36;
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = 2 + Math.random()*5;
    confettis.push({
      x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 2,
      r: 6*(0.6+Math.random()*0.9), c: Math.random()>.5? '#ff6eb6' : '#ffb3db',
      life: 900 + Math.random()*600, born: performance.now(), heart:true
    });
  }
  if(!anim) requestAnimationFrame(confettiLoop);
}

/* -----------------------
   UI flow & timing (card messages)
   ----------------------- */
const introCard = document.getElementById('introCard');
const startBtn = document.getElementById('startBtn');
const msgCard = document.getElementById('message');
const final = document.getElementById('final');
const replay = document.getElementById('replay');
let timers = [];

function showMsg(text, dur=2600){
  msgCard.textContent = text; msgCard.classList.add('show');
  timers.push(setTimeout(()=> msgCard.classList.remove('show'), dur));
}

startBtn.addEventListener('click', ()=> {
  introCard.classList.add('hide');
  // slight delay for polish
  setTimeout(()=> {
    createTargets(); spawnHearts();
  }, 420);
  // messages: coordinated, inside cards
  timers.push(setTimeout(()=> showMsg("Ä°ÅŸte ÅŸimdi daha iyisin â€” bÃ¶yle gÃ¼lmeye devam et", 3200), 2400));
  timers.push(setTimeout(()=> showMsg("Bu hastalÄ±k tatlÄ±lÄ±ÄŸÄ±na yenilecek â€” az kaldÄ±, ÅŸimdi dinlen ðŸ’–", 6200), 6200));
  timers.push(setTimeout(()=> { final.classList.add('show'); }, 10600));
});

/* replay resets */
replay.addEventListener('click', ()=>{
  // clear timers
  timers.forEach(t=>clearTimeout(t)); timers=[];
  // clear visuals
  final.classList.remove('show');
  msgCard.classList.remove('show');
  confettis = [];
  hearts = [];
  ctx.clearRect(0,0,W,H);
  createTargets();
  spawnHearts();
  // message sequence again
  timers.push(setTimeout(()=> showMsg("Ä°ÅŸte ÅŸimdi daha iyisin â€” bÃ¶yle gÃ¼lmeye devam et", 3200), 2400));
  timers.push(setTimeout(()=> showMsg("Bu hastalÄ±k tatlÄ±lÄ±ÄŸÄ±na yenilecek â€” az kaldÄ±, ÅŸimdi dinlen ðŸ’–", 6200), 6200));
  timers.push(setTimeout(()=> { final.classList.add('show'); }, 10600));
});

/* small accessibility: start by pressing Space */
window.addEventListener('keydown', e=>{ if(e.code==='Space' && !introCard.classList.contains('hide')) startBtn.click(); });

/* init three and draw ambient */
initThree();
createTargets();
spawnHearts(); // show once so initial impression â€” you can avoid auto spawn by removing this

</script>
</body>
</html>
