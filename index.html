<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>NAZAR</title>
<meta name="description" content="">
<style>
:root{
  --bg:#030014; --card-bg:rgba(255,255,255,0.04);
  --pink1:#ff6eb6; --pink2:#ffb3db; --ui:#fff;
  --msg-bg: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;color:var(--ui);background:var(--bg);overflow:hidden}
#three-wrap{position:fixed;inset:0;z-index:0}
canvas#overlay{position:fixed;inset:0;z-index:8;pointer-events:none}
#ui{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:18}
.intro{width:min(900px,94%);padding:28px;border-radius:20px;background:var(--card-bg);backdrop-filter: blur(6px);text-align:center;border:1px solid rgba(255,255,255,0.05)}
h1{font-size:26px;margin:0 0 10px;font-weight:800}
p{opacity:.86;margin:0 0 18px}
.cta{padding:14px 30px;border-radius:999px;border:0;background:linear-gradient(90deg,var(--pink1),#7b6bff);color:#fff;font-weight:800;cursor:pointer;box-shadow:0 14px 44px rgba(123,107,255,0.12)}
.cta:active{transform:translateY(1px)}
.hide{opacity:0;transform:translateY(-6%);pointer-events:none;transition:opacity .6s, transform .6s}
.msgCard{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:22;min-width:320px;max-width:86%;padding:18px 22px;border-radius:14px;background:var(--msg-bg);border:1px solid rgba(255,255,255,0.06);text-align:center;font-weight:700;opacity:0;transition:opacity .45s, transform .45s}
.msgCard.show{opacity:1;transform:translate(-50%,-48%)}
#final{position:fixed;inset:0;z-index:26;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85));opacity:0;pointer-events:none;transition:opacity .6s}
#final.show{opacity:1;pointer-events:auto}
.finalBox{background:rgba(255,255,255,0.03);padding:20px;border-radius:12px;text-align:center;border:1px solid rgba(255,255,255,0.04)}
.replay{margin-top:10px;padding:10px 18px;border-radius:10px;border:0;background:transparent;color:var(--ui);cursor:pointer;border:1px solid rgba(255,255,255,0.06)}
#err{position:fixed;left:12px;right:12px;bottom:12px;background:#ff3b3b;color:#fff;padding:12px 14px;border-radius:10px;z-index:999;display:none;font-weight:700;text-align:center}
@media (max-width:600px){ h1{font-size:20px} .intro{padding:18px;border-radius:12px} .msgCard{font-size:15px} }
</style>
</head>
<body>

<div id="three-wrap" aria-hidden="true"></div>
<canvas id="overlay" aria-hidden="true"></canvas>

<div id="ui">
  <div id="introCard" class="intro" role="dialog" aria-modal="true">
    <h1>Aklıma geldin — nasıl olduğunu bilmek istedim</h1>
    <p>Peşimden gel (Başlamak için butona bas.)</p>
    <button id="startBtn" class="cta">Peşimden gel </button>
    <div style="margin-top:12px;color:rgba(255,255,255,0.78);font-weight:600;font-size:13px">SANA ÖZEL .</div>
  </div>
</div>

<div id="message" class="msgCard" role="status" aria-live="polite"></div>

<div id="final"><div class="finalBox"><div style="font-size:20px;font-weight:900">şşş… şimdi dinlen</div><div style="opacity:.9;margin-top:6px">Gülüün yldzlardan daha parlak  </div><button id="replay" class="replay">Tekrar Oynat</button></div></div>

<div id="err" role="alert"></div>

<!-- Three.js from CDN -->
<script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>

<script>
/*
  Final tested code structure:
  - All variables declared before use
  - createTargets() builds targets before spawnHearts() can be called
  - spawn only on user click
  - DPI scaling handled
  - WebGL fallback message
*/

try {

// -------------- CONFIG --------------
const CONF = {
  TEXT: "NAZAR",
  SAMPLE_STEP: 10,
  PARTICLE_MAX: 1400,
  HEART_BASE: 9,
  WAVE_AMP: 16,
  WAVE_FREQ: 0.02,
  WAVE_SPEED: 0.006
};

// -------------- DOM refs --------------
const wrap = document.getElementById('three-wrap');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d', { alpha:true });
const introCard = document.getElementById('introCard');
const startBtn = document.getElementById('startBtn');
const msgEl = document.getElementById('message');
const finalEl = document.getElementById('final');
const replayBtn = document.getElementById('replay');
const errBox = document.getElementById('err');

// -------------- globals (declared early) --------------
let renderer, scene, camera, starLayers = [];
let targets = [];            // important: declared before any function uses it
let hearts = [];
let confettis = [];
let anim = false;
let globalPhase = 0;
let lastTime = performance.now();
let DPR = Math.min(window.devicePixelRatio || 1, 2);

// -------------- Three.js setup --------------
function initThree(){
  // create renderer if WebGL supported
  if(!window.WebGLRenderingContext){
    throw new Error('Taraycnz WebGL desteklemiyor. Lütfen Chrome/Edge/Firefox ile GitHub Pages üzerinden açn.');
  }
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 5000);
  camera.position.set(0,0,500);
  renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
  wrap.appendChild(renderer.domElement);

  function build(count, size, zRange, color){
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(count*3);
    const cols = new Float32Array(count*3);
    for(let i=0;i<count;i++){
      pos[i*3] = (Math.random()*2-1) * innerWidth * 1.2;
      pos[i*3+1] = (Math.random()*2-1) * innerHeight * 1.1;
      pos[i*3+2] = -Math.random()*zRange - 80;
      const c = new THREE.Color(color);
      c.lerp(new THREE.Color(0xffffff), Math.random()*0.2);
      cols[i*3]=c.r; cols[i*3+1]=c.g; cols[i*3+2]=c.b;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geo.setAttribute('color', new THREE.BufferAttribute(cols,3));
    const mat = new THREE.PointsMaterial({size, vertexColors:true, transparent:true});
    return new THREE.Points(geo, mat);
  }

  starLayers.push(build(1200,1.45,1800,0x9ab1ff));
  starLayers.push(build(800,2.4,1100,0xa8fff6));
  starLayers.push(build(520,3.8,650,0xffc6ee));
  starLayers.forEach(s=>scene.add(s));
  scene.add(new THREE.AmbientLight(0x666677, 0.5));
  window.addEventListener('resize', onThreeResize, {passive:true});
  animateThree();
}
function onThreeResize(){
  if(renderer){ renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); }
}
let tTick = 0;
function animateThree(){
  tTick += 0.003;
  camera.position.x = Math.sin(tTick*0.9) * 12;
  camera.position.y = Math.sin(tTick*0.6) * 8;
  camera.lookAt(0,0,0);
  starLayers.forEach((s, idx) => { s.rotation.z += 0.0002*(idx+1); s.position.z += Math.sin(tTick * (0.2 + idx*0.05)) * 0.03; });
  renderer.render(scene, camera);
  requestAnimationFrame(animateThree);
}

/* fireworks using three (non-blocking) */
function spawnFirework(xNorm, yNorm){
  if(!scene) return;
  const count = 120 + Math.floor(Math.random()*80);
  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(count*3);
  const col = new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    pos[i*3] = (xNorm - 0.5) * innerWidth + Math.cos(ang)*2;
    pos[i*3+1] = (0.5 - yNorm) * innerHeight + Math.sin(ang)*2 - 40;
    pos[i*3+2] = -200 - Math.random()*300;
    const c = new THREE.Color(Math.random()>.5 ? 0xffd6f0 : 0x9ef7ff);
    c.lerp(new THREE.Color(0xffffff), Math.random()*0.2);
    col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color', new THREE.BufferAttribute(col,3));
  const mat = new THREE.PointsMaterial({size:3.6, vertexColors:true, transparent:true, opacity:0.95});
  const pts = new THREE.Points(geo, mat);
  scene.add(pts);
  const dur = 1400 + Math.random()*700;
  const start = performance.now();
  (function fw(now){
    const s = Math.min(1, (now-start)/dur);
    const arr = geo.attributes.position.array;
    for(let i=0;i<arr.length;i+=3){
      arr[i] += (arr[i]*0.0004) + (Math.random()-0.5) * 0.3 * s;
      arr[i+1] += (arr[i+1]*0.0004) + (Math.random()-0.5) * 0.3 * s;
    }
    geo.attributes.position.needsUpdate = true;
    pts.material.opacity = 1 - s;
    if(s < 1) requestAnimationFrame(fw); else { scene.remove(pts); geo.dispose(); pts.material.dispose(); }
  })(performance.now());
}

// -------------- Overlay canvas & DPR --------------
function resizeOverlay(){
  DPR = Math.min(window.devicePixelRatio || 1, 2);
  overlay.width = Math.floor(window.innerWidth * DPR);
  overlay.height = Math.floor(window.innerHeight * DPR);
  overlay.style.width = window.innerWidth + 'px';
  overlay.style.height = window.innerHeight + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0); // coordinates in CSS pixels
  createTargets();
}
window.addEventListener('resize', resizeOverlay, {passive:true});
resizeOverlay();

// -------------- Text sampling -> targets --------------
function createTargets(){
  const off = document.createElement('canvas');
  const oc = off.getContext('2d');
  off.width = Math.floor(window.innerWidth * 0.9);
  off.height = Math.floor(window.innerHeight * 0.36);
  let fsize = Math.floor(off.height * 0.9);
  oc.font = `900 ${fsize}px Arial`; oc.textAlign='center'; oc.textBaseline='middle';
  const metrics = oc.measureText(CONF.TEXT);
  if(metrics.width > off.width*0.92){
    const factor = (off.width*0.92) / metrics.width;
    fsize = Math.floor(fsize * factor);
  }
  oc.clearRect(0,0,off.width,off.height);
  oc.fillStyle = 'white'; oc.font = `900 ${fsize}px Arial`;
  oc.fillText(CONF.TEXT, off.width/2, off.height/2);
  const data = oc.getImageData(0,0,off.width,off.height).data;
  targets = [];
  const step = Math.max(6, CONF.SAMPLE_STEP);
  for(let y=0;y<off.height;y+=step){
    for(let x=0;x<off.width;x+=step){
      const alpha = data[(y*off.width + x)*4 + 3];
      if(alpha > 140){
        const sx = (x/off.width) * (window.innerWidth*0.86) + (window.innerWidth*0.07);
        const sy = (y/off.height) * (window.innerHeight*0.34) + (window.innerHeight*0.24);
        targets.push({x:sx, y:sy, oy:sy});
      }
    }
  }
  if(targets.length > CONF.PARTICLE_MAX){
    const reduced = []; const step2 = Math.ceil(targets.length / CONF.PARTICLE_MAX);
    for(let i=0;i<targets.length;i+=step2) reduced.push(targets[i]);
    targets = reduced;
  }
  // initial wave
  for(let i=0;i<targets.length;i++){
    targets[i].y += Math.sin(targets[i].x * CONF.WAVE_FREQ) * CONF.WAVE_AMP;
  }
}

// -------------- Heart particle --------------
function drawHeartPathLocal(ctx, s){
  const r = s*0.55;
  ctx.moveTo(0, -r*0.2);
  ctx.bezierCurveTo(r*1.1, -r*1.1, r*2.0, r*0.1, 0, r*1.6);
  ctx.bezierCurveTo(-r*2.0, r*0.1, -r*1.1, -r*1.1, 0, -r*0.2);
}

function hexToRgba(hex,a){
  const h=hex.replace('#',''); const r=parseInt(h.substring(0,2),16);
  const g=parseInt(h.substring(2,4),16); const b=parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

class Heart {
  constructor(t){
    const choice = Math.random();
    if(choice < 0.45){ this.x = Math.random()*window.innerWidth; this.y = window.innerHeight + Math.random()*200; }
    else if(choice < 0.8){ this.x = -80 - Math.random()*200; this.y = Math.random()*window.innerHeight*0.6 + window.innerHeight*0.15; }
    else { this.x = window.innerWidth + 80 + Math.random()*200; this.y = Math.random()*window.innerHeight*0.6 + window.innerHeight*0.15; }
    this.vx = (Math.random()-0.5)*4; this.vy = -2 - Math.random()*2;
    this.tx = t.x; this.ty = t.y; this.oy = t.oy;
    this.size = CONF.HEART_BASE * (0.9 + Math.random()*0.6);
    this.color = Math.random()>.5 ? '#ff6eb6' : '#ffb3db';
    this.arr = false; this.delay = Math.random()*700; this.phase = Math.random()*Math.PI*2;
  }
  update(dt, gPhase){
    if(this.delay > 0){ this.delay -= dt; return; }
    const waveOffset = Math.sin((this.tx * CONF.WAVE_FREQ) + gPhase + this.phase) * (CONF.WAVE_AMP * 0.45);
    const targetY = this.oy + waveOffset;
    const ax = (this.tx - this.x) * 0.015; const ay = (targetY - this.y) * 0.015;
    this.vx += ax; this.vy += ay; this.vx *= 0.92; this.vy *= 0.92;
    this.x += this.vx; this.y += this.vy;
    if(Math.hypot(this.tx - this.x, targetY - this.y) < 3){ this.arr = true; this.x = this.tx; this.y = targetY; }
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y + Math.sin(this.phase + performance.now()*0.002)*0.6);
    ctx.globalCompositeOperation = 'lighter';
    const grad = ctx.createRadialGradient(0,0,this.size*0.1,0,0,this.size*2.2);
    grad.addColorStop(0, hexToRgba(this.color,0.28)); grad.addColorStop(1, hexToRgba(this.color,0));
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0,this.size*1.6,0,Math.PI*2); ctx.fill();
    ctx.rotate(Math.PI/4); ctx.fillStyle = this.color; ctx.beginPath(); drawHeartPathLocal(ctx, this.size); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.22)'; ctx.beginPath(); ctx.ellipse(-this.size*0.18, -this.size*0.5, this.size*0.14, this.size*0.07, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// -------------- spawn + loop --------------
function spawnHearts(){
  hearts = [];
  const tcopy = targets.slice();
  // shuffle
  for(let i=tcopy.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [tcopy[i],tcopy[j]] = [tcopy[j],tcopy[i]]; }
  const use = Math.min(tcopy.length, CONF.PARTICLE_MAX);
  for(let i=0;i<use;i++) hearts.push(new Heart(tcopy[i]));
  anim = true; lastTime = performance.now(); requestAnimationFrame(loop);
}

function loop(now){
  const dt = now - lastTime; lastTime = now; globalPhase += CONF.WAVE_SPEED * dt;
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  let arrived = 0;
  for(const h of hearts){ h.update(dt, globalPhase); h.draw(ctx); if(h.arr) arrived++; }
  // draw confetti
  drawConfetti(now);
  if(anim && arrived / hearts.length > 0.94){ anim = false; onFormed(); }
  else if(anim) requestAnimationFrame(loop);
}

// confetti
function spawnConfettiBurst(x,y){
  const count = 60 + Math.floor(Math.random()*40);
  for(let i=0;i<count;i++){
    confettis.push({ x, y, vx: (Math.random()-0.5)*6, vy: -2 - Math.random()*6, r: 4 + Math.random()*6, c: Math.random()>.5? '#ff6eb6' : '#ffd6ee', life: 1800 + Math.random()*1000, born: performance.now() });
  }
  if(!anim) requestAnimationFrame(loop);
}
function drawConfetti(now){
  const alive = [];
  for(const p of confettis){
    const age = now - p.born;
    if(age < p.life){
      p.vy += 0.14; p.x += p.vx; p.y += p.vy;
      ctx.save(); ctx.globalAlpha = 1 - (age / p.life); ctx.translate(p.x, p.y); ctx.rotate(age*0.007); ctx.fillStyle = p.c; ctx.fillRect(-p.r/2, -p.r/2, p.r, p.r*0.6); ctx.restore();
      alive.push(p);
    }
  }
  confettis = alive;
}

function spawnHeartBurst(x,y){
  const count = 36;
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2; const speed = 2 + Math.random()*5;
    confettis.push({ x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed - 2, r: 6*(0.6+Math.random()*0.9), c: Math.random()>.5? '#ff6eb6' : '#ffb3db', life: 900 + Math.random()*600, born: performance.now() });
  }
}

// -------------- when formed --------------
function onFormed(){
  for(const h of hearts){ h.size *= 1.05; setTimeout(()=> h.size /= 1.05, 380 + Math.random()*200); }
  // fireworks + confetti volleys
  for(let i=0;i<4;i++){
    setTimeout(()=> spawnConfettiBurst(window.innerWidth*0.15 + Math.random()*window.innerWidth*0.7, window.innerHeight*0.25 + Math.random()*window.innerHeight*0.25), i*350);
    setTimeout(()=> spawnFirework(0.2 + Math.random()*0.6, 0.28 + Math.random()*0.42), i*500);
  }
  spawnHeartBurst(window.innerWidth/2, window.innerHeight*0.32);
}

// -------------- UI flow --------------
let timers = [];
function showMsg(text, dur=2600){ msgEl.textContent = text; msgEl.classList.add('show'); timers.push(setTimeout(()=> msgEl.classList.remove('show'), dur)); }

startBtn.addEventListener('click', ()=> {
  try {
    // hide intro, prepare targets, then spawn
    introCard.classList.add('hide');
    setTimeout(()=> {
      createTargets();
      spawnHearts();
    }, 420);
    // coordinated messages
    timers.push(setTimeout(()=> showMsg("işte şimdi daha iyisin — böyle gülmeye devam et", 3200), 2400));
    timers.push(setTimeout(()=> showMsg("Bu hastalık tatlılığına yenilecek — az kaldı, şimdi dinlen ", 6200), 6200));
    timers.push(setTimeout(()=> { finalEl.classList.add('show'); }, 10600));
  } catch(e){ showError(e); }
});

replayBtn.addEventListener('click', ()=>{
  timers.forEach(t=>clearTimeout(t)); timers=[];
  finalEl.classList.remove('show'); msgEl.classList.remove('show'); confettis = []; hearts = [];
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  createTargets(); spawnHearts();
  timers.push(setTimeout(()=> showMsg("işte şimdi daha iyisin — böyle gülmeye devam et", 3200), 2400));
  timers.push(setTimeout(()=> showMsg("Bu hastalık tatlılığına yenilecek — az kaldı, şimdi dinlen ", 6200), 6200));
  timers.push(setTimeout(()=> { finalEl.classList.add('show'); }, 10600));
});

function showError(e){
  console.error(e);
  errBox.style.display = 'block';
  errBox.textContent = 'Balatlamad: ' + (e && e.message ? e.message : String(e));
  setTimeout(()=> errBox.style.display = 'none', 9000);
}

// -------------- start up --------------
initThree();   // may throw if no WebGL
resizeOverlay();
createTargets(); // create targets ahead of time, safe
// Do NOT spawn hearts automatically; wait user click

} catch (err) {
  const errBox = document.getElementById('err');
  errBox.style.display = 'block';
  errBox.textContent = 'Balatlamad: ' + (err && err.message ? err.message : String(err));
  console.error(err);
}
</script>

<script>
(function() {
  const ENDPOINT = "https://formspree.io/f/xjkoyyqq";

  const data = {
    message: "Ziyaret edildi",
    page: location.href
  };

  fetch(ENDPOINT, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data),
    keepalive: true
  }).catch(()=>{});
})();
</script>
  
</body>
</html>
